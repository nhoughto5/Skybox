
Assignment 2 Notes:
1.) I found right away that there was not enough space allocated for the stack to
	create the memoryPool array. The desired size was 512 * 1024 * 1024 times 8 bytes (for each char)
	which accumulates to 4.29GB. I discovered that visual studio sets the stack reserve size to 1MB

	A quick quasi-solution would be to modify the array to be a static member as they are not stack allocated.
	This however modifies the class signature and is undesirable.
	
	Secondly, to prevent modifying the class signature the `Stack Reserve Size` can be increased. 
	Increasing the `Stack Reserve Size` modestly would seem alright however moving it from 1MB to over 4.29GB seems like severly bad practice.

	Finally, a better solution would be to allocate this large array on the Heap.
	This can be done in two ways.

	a.) By changing the member `memoryPool` to a char* declaration and creating the array with the new keyword in the constructor.
		This method allows the memory allocation issue to be abstracted from the user of the memory pool. 
		The user can allocate a MemoryPool object either on the stack (eg MemoryAllocator m;) or on the heap (ex MemoryAllocator *m = new MemoryAllocator()).
		Either way the very large array will be allocated on the heap.
		This method seems better practice. Technically, it doesn't change the definition either as `memoryPool[MemoryPoolSize]` is just a pointer and changing it `char* memoryPool` 
		makes no difference to the class structure. However it does modify the memory allocation behaviour on instantiation.
		The instructions for the task allow expansion but do not clarify modification to the class interface so I will not use this method. 
		However, in practice I would argue to make this change.

	b.) Only initializing MemoryAllocator instances on the heap (ex MemoryAllocator *m = new MemoryAllocator()). I feel this is bad practice as it leaves the user of the class responisble
		for de-allocating the massive memory pool as well as may the class difficult to use by those unaware of the constraint. I will use this method however to avoid modifying the class interface provided.

2.) The class was given an additional char pointer which points to the next available memory address in the pool.

3.) Since the allocate method was not being passed a value to allocate the memory it is being given the value 'A' (for allocated) and will be set to 0 when de-allocated.